{"branch_name": "refs/heads/master", "content": "<repo_name>kirenewardainijoas/rest-server<file_sep>/SI_PEGADAIAN/application/controllers/api/Nasabah.php\n<?php\n\nuse Restserver\\Libraries\\REST_Controller;\n\ndefined('BASEPATH') or exit('No direct script access allowed');\n\nrequire APPPATH . 'libraries/REST_Controller.php';\nrequire APPPATH . 'libraries/Format.php';\n\nclass Nasabah extends REST_Controller\n{\n\n\tpublic function __construct()\n\t{\n\t\tparent::__construct();\n\t\t$this->load->model('Nasabah_model');\n\t}\n\n\tpublic function index_get()\n\t{\n\t\t$id = $this->get('id');\n\n\t\tif ($id === null) {\n\t\t\t$data_nasabah = $this->Nasabah_model->getNasabah();\n\t\t} else {\n\t\t\t$data_nasabah = $this->Nasabah_model->getNasabah($id);\n\t\t}\n\n\t\tif ($data_nasabah) {\n\t\t\t$this->response([\n\t\t\t\t'status' => true,\n\t\t\t\t'data' => $data_nasabah\n\t\t\t], REST_Controller::HTTP_OK);\n\t\t} else {\n\t\t\t$this->response([\n\t\t\t\t'status' => false,\n\t\t\t\t'message' => 'id not found'\n\t\t\t], REST_Controller::HTTP_NOT_FOUND);\n\t\t}\n\t}\n\n\tpublic function index_delete()\n\t{\n\t\t$id\t= $this->delete('id');\n\n\t\tif ($id === null) {\n\t\t\t$this->response([\n\t\t\t\t'status' => false,\n\t\t\t\t'message' => 'provide an id!'\n\t\t\t], REST_Controller::HTTP_BAD_REQUEST);\n\t\t} else {\n\t\t\tif ($this->Nasabah_model->deleteNasabah($id) > 0) {\n\t\t\t\t$this->response([\n\t\t\t\t\t'status' => true,\n\t\t\t\t\t'id' => $id,\n\t\t\t\t\t'message' => 'deleted.'\n\t\t\t\t], REST_Controller::HTTP_NO_CONTENT);\n\t\t\t} else {\n\t\t\t\t$this->response([\n\t\t\t\t\t'status' => false,\n\t\t\t\t\t'message' => 'id not found'\n\t\t\t\t], REST_Controller::HTTP_BAD_REQUEST);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic function index_post()\n\t{\n\t\t$data = [\n\t\t\t'first_name' => $this->post('first_name'),\n\t\t\t'last_name' => $this->post('last_name'),\n\t\t\t'email' => $this->post('email'),\n\t\t\t'gender' => $this->post('gender')\n\t\t];\n\n\t\tif ($this->Nasabah_model->createNasabah($data) > 0) {\n\t\t\t$this->response([\n\t\t\t\t'status' => true,\n\t\t\t\t'message' => 'new data nasabah has been created.'\n\t\t\t], REST_Controller::HTTP_CREATED);\n\t\t} else {\n\t\t\t$this->response([\n\t\t\t\t'status' => false,\n\t\t\t\t'message' => 'failed to created new data'\n\t\t\t], REST_Controller::HTTP_BAD_REQUEST);\n\t\t}\n\t}\n\n\tpublic function index_put()\n\t{\n\t\t$id  = $this->put('id');\n\t\t$data = [\n\t\t\t'first_name' => $this->post('first_name'),\n\t\t\t'last_name' => $this->post('last_name'),\n\t\t\t'email' => $this->post('email'),\n\t\t\t'gender' => $this->post('gender')\n\t\t];\n\n\t\tif ($this->Nasabah_model->updateNasabah($data, $id) > 0) {\n\t\t\t$this->response([\n\t\t\t\t'status' => true,\n\t\t\t\t'message' => 'new data nasabah has been update.'\n\t\t\t], REST_Controller::HTTP_NO_CONTENT);\n\t\t} else {\n\t\t\t$this->response([\n\t\t\t\t'status' => false,\n\t\t\t\t'message' => 'failed to update  data'\n\t\t\t], REST_Controller::HTTP_BAD_REQUEST);\n\t\t}\n\t}\n}\n<file_sep>/SI_PEGADAIAN/application/models/Nasabah_model.php\n<?php\n\nclass Nasabah_model extends CI_Model\n{\n\tpublic function getNasabah($id = null)\n\t{\n\t\tif ($id === null) {\n\t\t\treturn $this->db->get('data_nasabah')->result_array();\n\t\t} else {\n\t\t\treturn $this->db->get_where('data_nasabah', ['id' => $id])->result_array();\n\t\t}\n\t}\n\n\tpublic function deleteNasabah($id)\n\t{\n\t\t$this->db->delete('data_nasabah', ['id' => $id]);\n\t\treturn $this->db->affected_rows();\n\t}\n\n\tpublic function createNasabah($data)\n\t{\n\t\t$this->db->insert('data_nasabah', $data);\n\t\treturn $this->db->affected_rows();\n\t}\n\n\tpublic function updateNasabah($data, $id)\n\t{\n\t\t$this->db->update('data_nasabah', $data, ['id' => $id]);\n\t\treturn $this->db->affected_rows();\n\t}\n}\n", "directory_id": "f971b1fcc3f9f6f0bb64e87f72e04ce2b30361be", "languages": ["PHP"], "num_files": 2, "repo_language": "PHP", "repo_name": "kirenewardainijoas/rest-server", "revision_id": "fc06b985eadc0678d72751945dffc599cbacbe5c", "snapshot_id": "4f8790707e8f8f0421295c15b59985b50a006c11", "license": "MIT License"}
{"branch_name": "refs/heads/master", "content": "<file_sep>import os\nimport socket\nimport sys\nimport threading\n\nfrom select import select\n\nwith socket.socket() as socket:\n    socket.connect(('localhost', os.environ['PORT']))\n\n\n    def read_input(socket):\n        while True:\n            message = input('> ')\n            socket.send(message.encode('utf-8'))\n\n\n    read_input_thread = threading.Thread(target=read_input, args=(socket,))\n    read_input_thread.start()\n\n    while True:\n        data = socket.recv(1024)\n        if not data:\n            break\n        print(data.decode('utf-8'))\n\n<file_sep>import socket\nimport threading\n\nclients = []\n\n\ndef broadcast_msg(msg, conn):\n    for c in clients:\n        if c is not conn:\n            try:\n                c.send(msg.encode('utf-8'))\n            except:\n                c.close()\n                if c in clients:\n                    clients.remove(c)\n\n\nwith socket.socket() as socket:\n    address, port = 'localhost', 9999\n\n    socket.bind((address, port))\n\n    print(f'bound ({address}, {port})')\n\n    print('accepting connection')\n    socket.listen()\n\n    while True:\n        conn, client_address = socket.accept()\n        clients.append(conn)\n\n\n        def handle_client_connection(conn, addr):\n            with conn:\n                while True:\n                    data = conn.recv(1024)\n                    if not data:\n                        break\n                    msg = f'> {addr}: {data.decode(\"utf-8\")}'\n                    print(msg)\n                    broadcast_msg(msg, conn)\n\n\n        threading.Thread(target=handle_client_connection, args=(conn, client_address)).start()\n<file_sep>altgraph        0.17\natomicwrites    1.3.0\nattrs           19.3.0\nautopep8        1.4.4\ncertifi         2020.4.5.1\nclick           7.1.1\ncolorama        0.4.3\ncycler          0.10.0\nentrypoints     0.3\nflake8          3.7.9\nFlask           1.1.1\nfuture          0.18.2\nitsdangerous    1.1.0\nJinja2          2.11.1\nkiwisolver      1.0.1\nmacholib        1.11\nMarkupSafe      1.1.1\nmatplotlib      3.1.3\nmccabe          0.6.1\nmkl-fft         1.0.15\nmkl-random      1.1.0\nmkl-service     2.3.0\nmore-itertools  8.2.0\nnumpy           1.18.1\npackaging       20.3\npefile          2019.4.18\npip             20.0.2\npluggy          0.13.1\npsutil          5.7.0\npy              1.8.1\npycodestyle     2.5.0\npycryptodome    3.8.2\npyflakes        2.1.1\nPyInstaller     3.6\npyparsing       2.4.6\npytest          5.3.5\npython-dateutil 2.8.1\npywin32         227\npywin32-ctypes  0.2.0\nsetuptools      44.0.0.post20200106\nsip             4.19.13\nsix             1.14.0\ntornado         6.0.4\nwcwidth         0.1.8\nWerkzeug        1.0.1\nwheel           0.34.2\nwincertstore    0.2", "directory_id": "3f21ee8fc74abedde92ae37de63a4923b560aab3", "languages": ["Text", "Python"], "num_files": 3, "repo_language": "Text", "repo_name": "zvikfir/python-course-chat", "revision_id": "a5827c10218a50831d8df52c96636403d7591fc1", "snapshot_id": "f777882988b23aab3b97ea98d293f4bd38c9a834", "license": "MIT License"}
{"branch_name": "refs/heads/master", "content": "<file_sep>#!/bin/bash\nrm -rf deploy/ && hyde gen && find deploy && git status deploy/ && git diff deploy && echo -e '\\033[32mTEST PASSED\\033[0m' || echo -e '\\033[31mTEST FAILED\\033[0m'\n<file_sep>---\nid: 2012-12-03-comments-disabled\ntitle: Comments disabled\ncomments: False\n---\n\nThis post has 'comments' metadata attribute set to False.\n\nIt won't display any comment related information.\n\n<file_sep>---\ntitle: Disqus comments\nid: disqus-based-post\nextends: disqusblog.j2\ndisqus: canvoki\n---\n\nYou can combine in the same blog post based on static comments with posts managed with Disqus.\nJust switch the extended template and provide a Disqus account as metadata.\n\nThis way you can still run your existing disqus comments without migrating data to the static way.\n\n<file_sep>from hyde.plugin import Plugin\nimport re\nimport hashlib\nimport urllib\n\n\n\"\"\"\nThis plugin enables the rendering of static comments,\nby making available, as metadata, comment info\nstored as independent source files for each comment.\n\"\"\"\n\n\n# TOTEST:\n# - If inreplyto and thread defined, takes inreplyto as replyto\n# - Neither inreplyto nor thread available -> AttributeError\n# - Just inreplyto -> thread = inreplyto\n# - Just thead -> inreplyto = thread\n# - inreplyto and thead -> no change\n# - Repeated comment id\n# - nested comments\n# - ncomments in nested comments\n# - meta.comments = True enables them\n# - avatar when\n#   - valid email\n#   - invalid email\n#   - explicit image provided\n#   - changing default via meta\n# - Sorting comments by date\n# - Threads\n# - Counting despite the threads\n\n\nclass CommentsPlugin(Plugin) :\n\tdef __init__(self, site) :\n\t\tsuper(CommentsPlugin, self).__init__(site)\n\t\tself._stripMetaRE = re.compile(\n\t\t\tr\"^\\s*(?:---|===)\\s*\\n((?:.|\\n)+?)\\n\\s*(?:---|===)\\s*\\n*\",\n\t\t\tre.MULTILINE)\n\n\tdef begin_site(self) :\n\n\t\tdef contentWithoutMeta(r) :\n\t\t\ttext = r.source_file.read_all()\n\t\t\tmatch = re.match(self._stripMetaRE, text)\n\t\t\treturn text[match.end():]\n\n\t\tdef commentAvatar(c) :\n\t\t\tif hasattr(c.meta, 'avataruri') and c.meta.avataruri :\n\t\t\t\treturn c.meta.avataruri\n\t\t\tif hasattr(c.meta, 'image') and c.meta.image :\n\t\t\t\treturn c.meta.image\n\t\t\tgravatar_default = c.node.meta.gravatar_default if 'gravatar_default' in c.node.meta else 'mm'\n\t\t\treturn gravatarFromEmail(c.meta.authoremail, gravatar_default) or None\n\n\t\tdef gravatarFromEmail(email, default='mm', size=32) :\n\t\t\t\"\"\"Given an email address composes the gravatar image uri.\n\t\t\tdefault says which strategy use when not found.\n\t\t\thttps://en.gravatar.com/site/implement/images/\n\t\t\t\"\"\"\n\t\t\tmd5 = hashlib.md5(email.lower().encode(\"utf-8\")).hexdigest()\n\t\t\treturn ( \"http://www.gravatar.com/avatar/\" + md5 + \"?\"\n\t\t\t\t+ urllib.urlencode({\n\t\t\t\t\t'd':default,\n\t\t\t\t\t's':str(32)\n\t\t\t\t\t}))\n\n\t\t# compile dicts of posts and comments by id\n\t\tcomments = {}\n\t\tposts = {}\n\t\tfor r in self.site.content.walk_resources() :\n\t\t\tif r.source_file.kind == 'comment' :\n\t\t\t\tif 'id' not in r.meta.to_dict() :\n\t\t\t\t\tself.logger.debug(\"Not id for comment %s\"%r)\n\t\t\t\tid = str(r.meta.id)\n\t\t\t\tif id in comments :\n\t\t\t\t\traise ValueError(\n\t\t\t\t\t\t\"Repeated comment id '%s' in comments %s and %s\" %(\n\t\t\t\t\t\t\tid, r, comments[id]))\n\t\t\t\tcomments[id] = r\n\t\t\telse :\n\t\t\t\tif 'id' not in r.meta.to_dict() : continue\n\t\t\t\tid = str(r.meta.id)\n\t\t\t\tif id in posts :\n\t\t\t\t\traise ValueError(\n\t\t\t\t\t\t\"Repeated post id '%s' in comments %s and %s\" %(\n\t\t\t\t\t\t\tid, r, posts[id]))\n\t\t\t\tposts[id] = r\n\n\t\t# Initialize comment related fields on posts\n\t\tfor post in posts.values() :\n\t\t\tpost.ncomments = 0\n\t\t\tpost.comments = []\n\n\t\t# Setting computed fields on comments\n\t\tfor comment in comments.values() :\n\t\t\tcomment.thread_children = []\n\t\t\tcomment.is_processable = False\n\t\t\tcomment.meta.listable=False\n\t\t\tcomment.uses_template=False\n\t\t\tcomment.text = contentWithoutMeta(comment)\n\t\t\tcomment.meta.avataruri = commentAvatar(comment)\n\n\t\tdef connectComment(comment, inreplyto) :\n\t\t\tself.logger.debug(\"Comment found: %s replying %s\"%(r,inreplyto))\n\t\t\tif inreplyto in comments :\n\t\t\t\tcomments[inreplyto].thread_children.append(comment)\n\t\t\telif inreplyto in posts :\n\t\t\t\tposts[inreplyto].comments.append(comment)\n\t\t\telse:\n\t\t\t\traise ValueError(\n\t\t\t\t\t\"Comment %s refering to an invalid resource '%s'\" %(\n\t\t\t\t\t\tr, inreplyto))\n\n\t\t# Build the thread tree\n\t\tfor comment in comments.values() :\n\t\t\tif 'inreplyto' in comment.meta.to_dict() :\n\t\t\t\tinreplyto = str(comment.meta.inreplyto)\n\t\t\t\tconnectComment(comment, inreplyto)\n\t\t\telif 'thread' in comment.meta.to_dict() :\n\t\t\t\tthread = str(comment.meta.thread)\n\t\t\t\tconnectComment(comment, thread)\n\t\t\t\tcomment.meta.inreplyto = thread\n\t\t\telse :\n\t\t\t\traise ValueError(\n\t\t\t\t\t\"Comment %s is missing either a 'thread' or 'inreplyto' meta attribute to be related\"%(\n\t\t\t\t\t\tcomment))\n\n\t\t# Sort by date and count comments\n\t\tdef recursiveSort(comments) :\n\t\t\tfor comment in comments :\n\t\t\t\trecursiveSort(comment.thread_children)\n\t\t\t\tcomments.sort(key=lambda x : x.meta.published)\n\t\tdef recursiveCount(comments) :\n\t\t\treturn sum((recursiveCount(c.thread_children) for c in comments), len(comments))\n\n\t\tdef recursiveDepend(post, comments) :\n\t\t\tpost.depends.extend( (\n\t\t\t\tcomment.relative_path\n\t\t\t\tfor comment in comments\n\t\t\t\tif comment.relative_path not in post.depends\n\t\t\t\t))\n\t\t\tfor comment in comments :\n\t\t\t\trecursiveDepend(post, comment.thread_children)\n\n\t\tfor post in posts.values() :\n\t\t\trecursiveSort(post.comments)\n\t\t\tpost.ncomments = recursiveCount(post.comments)\n\t\t\tif not hasattr(post, 'depends'):\n\t\t\t\tpost.depends = []\n\t\t\trecursiveDepend(post, post.comments)\n\n\n\n\n<file_sep><?php\n$debug = 0;\n$from_address = \"<EMAIL>\";\n$to_address = \"<EMAIL>\";\n$subject = \"[Hyde comments] New comment received\";\n\n$debug and ini_set('display_errors', 'On');\n$debug and error_reporting(E_ALL | E_STRICT);\n\nfunction badRequest($message = \"Error 400: Bad Request\")\n{\n\theader(\"HTTP/1.1 400 Bad Request\");\n\techo $message;\n\texit();\n}\n\n\n\nif (! isset($_SERVER['HTTP_REFERER'])) badRequest();\n$referrer = $_SERVER['HTTP_REFERER'];\n\nif ($debug)\n{\n\techo '<pre>';\n\tvar_dump($_POST);\n}\n\nclass MissingField extends Exception\n{\n\tfunction __construct($field)\n\t{\n\t\tparent::__construct(\"Missing field '$field'\");\n\t}\n};\n\n/// Safely retrieves post data or throws unless a default value is provided\nfunction post($field, $default=Null)\n{\n\tif (!isset($_POST[$field]))\n\t{\n\t\tif (!is_null($default)) return $default;\n\t\tthrow new MissingField($field);\n\t}\n\tif (empty($_POST[$field]) and !is_null($default))\n\t\treturn $default;\n\treturn $_POST[$field];\n}\n\nfunction sluggify($string)\n{\n\t$result = preg_replace('/[^A-Za-z0-9-]+/', '-', $string); // Weird into '-'\n\t$result = preg_replace('/--*/', '-', $result); // Collapse multiple '-'\n\t$result = preg_replace('/-$/', '', $result); // Remove '-' at ending\n\t$result = preg_replace('/^-/', '', $result); // Remove '-' at begining\n\treturn $result;\n}\n\ndate_default_timezone_set(\"UTC\");\n$time = date(\"Y-m-d H:i:s\");\n$slug_time = date(\"Ymd-His\");\n$title_excerpt_size=20;\n$random_hash = md5(rand());\n\ntry\n{\n\t$comment = post('comment');\n\t$title_excerpt = substr($comment, 0, strpos(wordwrap($comment, $title_excerpt_size), \"\\n\"));\n\t$thread = post('thread');\n\t$inreplyto = post('inreplyto');\n\t$author = post('name');\n\t$authoremail = post('email');\n\t// Optional params\n\t$authoruri = post('website', \"\");\n\t$title = post('title', $title_excerpt);\n}\ncatch (MissingField $e)\n{\n\tbadRequest($e->getMessage());\n}\n$short_hash = substr($random_hash,-6);\n$id = sluggify(\"$thread-$slug_time-$short_hash-$title\");\n\n$comment_file = <<<EOF\n---\nid: '$id'\nthread: '$thread'\ninreplyto: '$inreplyto'\ntitle: '$title'\npublished: !!timestamp '$time'\nupdated: !!timestamp '$time'\nauthor: \"$author\"\nauthoruri: $authoruri\nauthoremail: $authoremail\n---\n$comment\nEOF;\n\nif ($debug)\n{\n\techo $comment_file;\n\techo '</pre>';\n}\n\n$message = <<<EOF\n--Multipart-boundary-$random_hash\nContent-Type: text/plain; charset=\"utf-8\n\nSomeone commented you post at:\n$referrer\n\nTo incorporate such comment into your blog,\nsave the attached file into the content folder\nand regenerate the blog with Hyde.\n\nAuthor: $author\nEmail: $authoremail\nWebsite: $authoruri\nTitle: $title\nContent:\n------------------\n$comment\n------------------\n\nSincerely,\n  your PHP backend for the Hyde static comments plugin.\n\n--Multipart-boundary-$random_hash\nContent-Type: text/yaml; name=\"$id.comment\"; charset=\"utf-8\"\nContent-Disposition: attachment\n\n$comment_file\nEOF;\n\nif (! $debug )\n{\n\n\t$ok = @mail(\n\t\t$to_address,\n\t\t$subject,\n\t\t$message,\n\t\tjoin(\"\\r\\n\",array(\n\t\t\t\"From: $from_address\",\n\t\t\t\"Reply-To: $from_address\",\n\t\t\t\"Content-Type: multipart/mixed; boundary=\\\"Multipart-boundary-$random_hash\\\"\" \n\t\t\t))\n\t\t);\n\tif ($ok)\n\t{\n\t\techo <<<EOF\n<html>\n<head> <meta charset=\"utf-8\" /> </head>\n<body>\n<p>Thanks. Your comment was properly submitted.\n</p><p>\nDo not expect the comments to appear immediately in the post\nas they have to wait for author's moderation.</p>\n<p><a href='$referrer'>Back to the post</a></p>\n</body>\n</html>\nEOF;\n\n\t}\n\telse\n\t{\n\t\techo <<<EOF\n<html>\n<head> <meta charset=\"utf-8\" /> </head>\n<body>\n<p>We are sorry. There was a problem submiting your comment.\n</p><p>\nBelow you have the content of your comment so that you can copy it and submit it later.</p>\n<pre>\nTitle: $title\n------------------\n$comment\n------------------\n</pre>\n<p><a href='$referrer'>Back to the post</a></p>\n</body>\n</html>\nEOF;\n\t}\n}\n\n?>\n<file_sep>hyde-comments: Static comments for Hyde static web generator\n============================================================\n\nWhat?\n-----\n\nThis is an extension of [Hyde] static web generator to incorporate\ncomments into your blog post while retaining both data and\nsimple server requirements.\n\nThe idea is that comments are stored as plain text files along\nwith your post text files and they are combined either on\ngeneration time or in rendering time using JavaScript.\n\nThis extension is in early stage and many things are to be defined.\nYou can participate on the decisions by contributing.\n\nWhy?\n----\n\nMost people using static blog generators either don't have comments\nor they have to rely on external services such as [Disqus].\nSuch services allow hosting comments and display them by\nadding an static javascript code to your template.\n\nSo, why that approach is not enough?\nYou should read the following [post][JeckyllStaticCommentsPost] by <NAME>\nthe author of an equivalent extension for [Jeckyll][Jeckyll] (Ruby based alter ego of Hyde).\n\nIn summary:\n\n* I want to have control over my data. I don't want to rely on an external service.\n* I want my blogging tools be free software (as in freedom, not gratis)\n\nDocumentation\n-------------\n\nCurrently, the behaviour of the extension is not yet well-defined.\nPlease, meanwhile rely on the examples which are pretty explanatory and on (glups!) the code.\n\nStatus\n------\n\nWhat works:\n\n- Posts include comments information provided as separate comment files\n\t- Comment files (.comment) can be placed anywhere in the content folder.\n\t- They are related to their post assigning 'comment.meta.thread' to 'post.meta.id'\n\t- Templates can acces the list of post comments by accessing 'post.comments'\n- Nested comments:\n\t- Comments are nested assigning 'child.meta.inreplyto' to 'parent.meta.id'\n\t- Top level comments just set 'child.meta.inreplyto' to the post id.\n\t- Children comments are available as 'parent.meta.children'\n- Comment template with stylable classes\n- Disabling or enabling comments in a post via meta.comment = True/False\n- Author avatars\n\t- Gravatar based on 'authoremail' if available.\n\t- Configurable [fallback gravatar](http://en.gravatar.com/site/implement/images/)\n\t- Explicit avatar from either 'image' or 'avataruri' metas.\n- Comment submission form (a web 1.0 one :-( )\n- Comment submission backend in php, that sends the comment file back to the author.\n\t- The author has to save it and regenerate the web site.\n\t- You can place the backend in a different hosting if you want. Just change the submission URI in 'meta.comment_handler_uri':.\n\t- Light-coupled: It is easily reimplementable in whatever language/framework your hosting allows.\n\t- If you want to automate more things, like regeneration or comment storage, all futs under the same API.\n- Post generation depends on its comments.\n- Fixed: Links are not generated when no author website is provided.\n\n\nWhat is to be implemented (TO-DO's):\n\n- AJAX based comment submission form\n- Generation can be threaded but there is no means yet to submit threaded comments by replying a given comment\n- Adding optional avatar field (upload or uri?)\n- Disabling comments submission via 'meta.commentsclosed' = True\n- Security concerns on comment content\n\t- Strip html tags\n\t- Spam links\n\t- Email addresses\n- Spam tools\n\t- Moderation by accepting a checksum\n\t- Pre-moderation with akismet\n- Unassisted automatic generation\n- Client side rendering\n\t- Generation of json data for comments\n\t- Regeneration of comment index json files when moderated\n\t- Dynamically building comments with javascript\n\t- Combine it with existing comments\n\t- JSON data tolerance (don't destroy existing comments when JSON data is missing)\n- Pingback\n- Likes\n\nWant to help? [Fork it in GitHub][GitHupHydeComments].\n\nDesign forces\n-------------\n\n### Comment rendering\n\nHow/when to render the comments within a post?\n\n* During blog generation\n* On browser via JavaScript\n\nThe first option can be implemented by adding special files to the site content,\nthat can be detected by extension or metadata.\nBuilding the comments as part of the site structure\nand rendering them by a template\n\nThe second option could be implemented\nby placing static [JSON] files for comments on a given URL\nand querying them from the post page.\nThere could be an index JSON file for each post with the URL's of the related comments which could be independent files.\n\nThe first option has the drawback that it has to be generated each time a comment is added.\nThe second option has the drawback that it requires JavaScript and that the crawlers (Google) cannot index comments content.\n\nAlso, the JavaScript option can add a feature to auto-reload the comments for updates.\nThis feature indeed opens a third hybrid option:\n\n* Statically generating comments which are available on generation time and updating them on browser.\n\nThis way if there is no JavaScript you still have the comments\ncrawlers have the static content available for rendering\nand users can see the comments without waiting for the site to be regenerated.\n\n### Comment submission\n\nThis part of the comment system requires server side scripting at least to receive the comments.\nBut the use of static web generators is often motivated by reasons such as:\n\n* Reducing the server load.\n* Being able to place the web whatever the languages provided by a given hosting.\n\nThe first motivation discourages the use of heavy duty server scripts.\nThe second one discourages from attaching the user to a given language and framework setup.\n\nNevertheless many users that are happy with that if some tasks are being conveniently automated.\n\nWe are not that constrained if we realize that:\n\n- Adding a comment is an infrequent task compared to page views, so the load is less than the one of a dynamic website if you want to compare with that.\n- We can place the submission script in a different host than the static website. Hosting restrictions and load can be reduced that way.\n- If they are simple enough, we can provide, with the same API, different back-ends that do different things using different technologies.\n\nSo what kind of things could do a back-end:\n\n- Sending an attached comment file by mail to the author so that she can store it and regenerate the website by hand.\n- Storing the comment on the site and notifying the author so that she can regenerate the blog.\n- Storing and regenerating the blog (convenient but dangerous)\n- Validating the author email (sending an email to the author so she can confirm the comment via a confirmation url)\n- Filtering for spam with Akismet or similar\n- Log-in, account management...\n\n\n\n[Hyde]: http://ringce.com/hyde\n[Disqus]: http://disqus\n[JeckyllStaticCommentsPost]: http://hezmatt.org/~mpalmer/blog/2011/07/19/static-comments-in-jekyll.html\n[Jeckyll]: http://jekyllrb.com/\n[JSON]: http://json.org\n[GitHupHydeComments]: https://github.com/vokimon/hyde-comments\n\n\n\n<file_sep>{% extends \"blog.j2\" %}\n\n{% block css %}\n{{ super() }}\n  <link rel=\"stylesheet\" href=\"{{ media_url('css/comments.css') }}\">\n{% endblock css %}\n\n{%- macro renderThread(comments) %}\n{% if comments %}\n<ul class='comment-thread'>\n{% for comment in comments | sort(attribute='meta.published') %}\n\t<li class='comment' id='{{ comment.meta.id }}'>\n\t<div class='comment-head'>\n\t{% if comment.meta.authoruri %}\n\t<a class='comment-avatar' target='_'\n\t\thref='{{comment.meta.authoruri|default(\"#\")}}'>\n\t\t<img\n\t\t\tstyle='max-height:32px;max-width:32px;'\n\t\t\tsrc='{{comment.meta.avataruri}}' /></a>\n\t<a class='comment-author' target='_'\n\t\thref='{{comment.meta.authoruri}}'>{{\n\t\t\tcomment.meta.author\n\t\t\t}}</a>\n\t{% else %}\n\t<span class='comment-avatar'><img style='max-height:32px;max-width:32px;' src='{{comment.meta.avataruri}}' /></span>\n\t<span class='comment-author'>{{ comment.meta.author }}</span>\n\t{% endif %}\n\t<div class='comment-title'>{{comment.meta.title}}</div>\n\t<div class='comment-reply'><a href='#commentform' onclick='setCurrentReply(\"{{comment.meta.id}}\", \"{{comment.meta.title}}\");'>Reply</a></div>\n\t<div class='comment-timestamp'>{{comment.meta.published}}</div>\n\t</div>\n\t<div class='comment-text'>\n\t{{ comment.text | markdown }}\n\t</div>\n{{- renderThread(comment.thread_children) }}\n\t</li>\n{% endfor%}\n</ul>\n{% endif %}\n{% endmacro %}\n\n{% block comments %}\n{%- if resource.meta.comments %}{# comments enabled in metadata? #}\n\n<h2>Comments</h2>\n<script>\n<!--\nfunction setCurrentReply(comment,title)\n{\n\tdocument.getElementById(\"inreplyto\").setAttribute(\"value\",comment);\n\tdocument.getElementById(\"comment-title\").setAttribute(\"value\",\"Re: \"+title);\n}\n-->\n</script>\n<h3>{{ resource.ncomments }} comments.</h3>\n\n{{ renderThread(resource.comments) }}\n\n<h3>Leave a comment</h3>\n<div class='comment-form'>\n<form id=\"commentform\" method=\"POST\" accept-charset='utf-8' action=\"{{ resource.meta.comment_handler_uri|default(\"/commentsubmit.php\") }}\">\n<input type=\"hidden\" name=\"thread\" value=\"{{resource.meta.id}}\" />\n<input type=\"hidden\" name=\"inreplyto\" value=\"{{resource.meta.id}}\" id='inreplyto' />\n<input type=\"hidden\" name=\"return_url\" value=\"{{ site.full_url(resource.get_relative_deploy_path()) }}\" />\n<div class='comment-form-content'>\n<div class='comment-form-title'>\n\t<input\n\t\ttype=\"text\"\n\t\tplaceholder='A subject'\n\t\tsize=\"25\"\n\t\tname=\"title\"\n\t\tid='comment-title'\n\t\t/>\n\t<label for='title'>Subject</label>&nbsp;(optional)\n</div>\n<div class='comment-form-text'>\n<textarea\n\tname=\"comment\"\n\tplaceholder='Leave a comment...'\n\trows=\"6\" cols=\"60\"\n\trequired='yes'\n\t>\n</textarea>\n</div>\n</div>\n<div class='comment-form-identify'>\n<div class='comment-form-name'>\n\t<input\n\t\ttype=\"text\"\n\t\tplaceholder='Your name'\n\t\tsize=\"25\"\n\t\trequired=\"yes\"\n\t\tname=\"name\"\n\t\t/>\n\t<label for='name'>Name</label>\n</div>\n<div class='comment-form-email'>\n\t<input\n\t\ttype=\"email\"\n\t\tplaceholder='<EMAIL>'\n\t\tsize=\"25\"\n\t\tname=\"email\"\n\t\trequired=\"yes\"\n\t\t/>\n\t<label for='email'>E-mail</label>&nbsp;(not&nbsp;published)\n</div>\n<div class='comment-form-website'>\n\t<input type=\"url\" placeholder='http://yourdomain.com' size=\"25\" name=\"website\" />\n\t<label for='website'>Website</label>&nbsp;(optional)\n</div>\n{# Should be display:none so that just bots fill it #}\n<div id='yuemail'>\n\t<input\n\t\ttype=\"email\"\n\t\tplaceholder='<EMAIL>'\n\t\tsize=\"25\"\n\t\tname=\"yuemail\"\n\t\tid='yuemail'\n\t\t/>\n</div>\n<div class='comment-form-submit'>\n\t<input type=\"submit\" name=\"submit\" value=\"Submit Comment\" />\n</div>\n</div>\n</form>\n<div class='clear'></div>\n</div>\n{%- endif %}\n\n{% endblock comments %}\n\n", "directory_id": "7513ed165c542079c55f2d18fe2b389969fe7c17", "languages": ["Shell", "HTML", "Markdown", "Jinja", "Python", "PHP"], "num_files": 7, "repo_language": "Shell", "repo_name": "vokimon/hyde-comments", "revision_id": "8099da7da23616f8676876f8fc2ef204848dd89a", "snapshot_id": "aeb93aea2392c5ae45df8f18befcf01d78b51413", "license": "MIT License"}
{"branch_name": "refs/heads/master", "content": "<file_sep>//\n//  ViewController.h\n//  MyQRCodeReader\n//\n//  Created by <NAME> on 26/05/14.\n//  Copyright (c) 2014 <NAME>. All rights reserved.\n//\n\n#import <UIKit/UIKit.h>\n#import <AVFoundation/AVFoundation.h>\n\n@interface ViewController : UIViewController <AVCaptureMetadataOutputObjectsDelegate>\n\n@end\n<file_sep>//\n//  ViewController.m\n//  MyQRCodeReader\n//\n//  Created by <NAME> on 26/05/14.\n//  Copyright (c) 2014 <NAME>. All rights reserved.\n//\n\n#import \"ViewController.h\"\n#import <AVFoundation/AVFoundation.h>\n\n@interface ViewController ()\n@property (weak, nonatomic) IBOutlet UIView *previewUIView;\n@property (weak, nonatomic) IBOutlet UILabel *readStatusLabel;\n@property (weak, nonatomic) IBOutlet UIBarButtonItem *StartBarButton;\n\n@property (strong, nonatomic) AVCaptureSession * captureSession;\n@property (strong, nonatomic) AVCaptureVideoPreviewLayer * videoPreviewLayer;\n@property (strong, nonatomic) AVAudioPlayer * audioPlayer;\n\n\n@property (nonatomic) BOOL isReading;\n@end\n\n@implementation ViewController\n\n#pragma mark - \n#pragma mark View Life Cycle\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n\tself.isReading = NO;\n    self.captureSession = nil;\n    [self loadBeepSoundWhenFinishReadQRCode];\n}\n\n- (void)didReceiveMemoryWarning\n{\n    [super didReceiveMemoryWarning];\n}\n\n#pragma mark - \n#pragma mark Start Read QR Code\n\n- (BOOL)startReading\n{\n    NSError *error;\n    \n    // add device camera\n    \n    AVCaptureDevice *captureDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];\n    \n    return YES;\n    \n    AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:captureDevice error:&error];\n    \n    if (!input) {\n        NSLog(@\"%@\", [error localizedDescription]);\n        return NO;\n    }\n    self.captureSession = [[AVCaptureSession alloc] init];\n    [self.captureSession addInput:input];\n    \n    AVCaptureMetadataOutput * captureMetadataOutput = [[AVCaptureMetadataOutput alloc] init];\n    [self.captureSession addOutput:captureMetadataOutput];\n    \n    // create dispatch queue totally used by this task\n    dispatch_queue_t dispatchQueue;\n    dispatchQueue = dispatch_queue_create(\"myQueue\", NULL);\n    [captureMetadataOutput setMetadataObjectsDelegate:self\n                                                queue:dispatchQueue];\n    \n    [captureMetadataOutput setMetadataObjectTypes:[NSArray  arrayWithObject:AVMetadataObjectTypeQRCode]];\n    \n    self.videoPreviewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.captureSession];\n    [self.videoPreviewLayer setVideoGravity:AVLayerVideoGravityResizeAspectFill];\n    [self.videoPreviewLayer setFrame:self.previewUIView.layer.bounds];\n    [self.previewUIView.layer addSublayer:self.videoPreviewLayer];\n    \n    [self.captureSession startRunning];\n    \n}\n\n\n-(void)stopReading\n{\n    [self.captureSession stopRunning];\n    self.captureSession = nil;\n    [self.videoPreviewLayer removeFromSuperlayer];\n}\n\n\n- (void)loadBeepSoundWhenFinishReadQRCode\n{\n    NSString * beepFilePath = [[NSBundle mainBundle] pathForResource:@\"beep\" ofType:@\"mp3\"];\n    NSURL * beepURL = [NSURL URLWithString:beepFilePath];\n    \n    NSError * error;\n    \n    self.audioPlayer = [[AVAudioPlayer alloc] initWithContentsOfURL:beepURL\n                                                              error:&error];\n    if (error) {\n        NSLog(@\"Could not play beep mp3 file.\");\n        NSLog(@\"%@\",[error localizedDescription]);\n    }\n    else {\n        [self.audioPlayer prepareToPlay];\n    }\n\n}\n\n\n#pragma mark-\n#pragma mark AVCaptureMetadataOutputObjects Delegate\n\n\n- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection\n{\n    if ((metadataObjects !=nil) && [metadataObjects count] > 0) {\n        AVMetadataMachineReadableCodeObject * metadataObj = [metadataObjects objectAtIndex:0];\n        if ([[metadataObj type]isEqualToString:AVMetadataObjectTypeQRCode])\n        {\n            // since we preform on secondary thread so here need to perform on main thread\n            \n            [self.readStatusLabel performSelectorOnMainThread:@selector(setText:) withObject:[metadataObj stringValue] waitUntilDone:NO];\n            \n            [self performSelectorOnMainThread:@selector(stopReading)\n                                   withObject:nil\n                                waitUntilDone:NO];\n            [self.StartBarButton performSelectorOnMainThread:@selector(setText:)\n                                                  withObject:@\"Srart!!\"\n                                               waitUntilDone:NO];\n            self.isReading = NO;\n            \n            if (self.audioPlayer) {\n                [self.audioPlayer play];\n            }\n        }\n    }\n}\n\n\n#pragma mark-\n#pragma mark Actions\n\n- (IBAction)startStopReadQRCode:(id)sender\n{\n    if (!self.isReading) {\n        if ([self startReading]) {\n            [self.StartBarButton setTitle:@\"Stop\"];\n            [self.readStatusLabel setText:@\"Scanning QR Code...\"];\n        }\n    } else {\n        \n        [self stopReading];\n        \n        [self.StartBarButton setTitle:@\"Start\"];\n        [self.readStatusLabel setText:@\"QR Code is not Running yet ><\"];\n    }\n    self.isReading = !self.isReading;\n    \n}\n\n\n@end\n", "directory_id": "3b0a42d33f0ddd9c12101d5e802e584caebd732a", "languages": ["Objective-C"], "num_files": 2, "repo_language": "Objective-C", "repo_name": "shanshan33/MyQRCodeReader", "revision_id": "eb0b660f6ef043bf1e3fc95fac38f6fd2d9d814e", "snapshot_id": "d5d96c051853871c58dee684959a0acfbf698af9"}
{"branch_name": "refs/heads/master", "content": "<file_sep># hello-world\nJust another respository\nThis is a test document\n", "directory_id": "3e6f17701cc3dc1371c8c0f73b07c4b5313e1208", "languages": ["Markdown"], "num_files": 1, "repo_language": "Markdown", "repo_name": "kumradhika/hello-world", "revision_id": "d7c038110459029be9006c88dc5a1a5de04e86db", "snapshot_id": "5816cd44411d639dac2d4437a8bcd85643ec730f", "license": "MIT License"}
